/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.reading.gv009864.advancedcomputing;

import com.reading.gv009864.advancedcomputing.airline.Airport;
import com.reading.gv009864.advancedcomputing.airline.Flight;
import com.reading.gv009864.advancedcomputing.data.AirportData;
import com.reading.gv009864.advancedcomputing.data.PassengerData;
import com.reading.gv009864.advancedcomputing.mapper.AirportMapper;
import com.reading.gv009864.advancedcomputing.mapper.PassengerMapper;
import com.reading.gv009864.advancedcomputing.reducer.Reducer;
import com.reading.gv009864.advancedcomputing.strings.CSV;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.commons.collections4.ListUtils;


import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

public class App {
    private static Logger log = LoggerFactory.getLogger(App.class);

    /**
        Create a list of flights based on the Flight ID
        Output should include passenger ID
        <key, List<value>>
        <FlightId, List<data>>
     */
    public static void main(String[] args) {
        // I guess the first thing to do would be to take the data in and read it before carrying on
        // Need to Map the input data to key value pairs
        // Will just work on doing the mapping the input to key value pairs for the first part before carrying on to the other steps in the process.

        // Lets take the AComp_passenger_data_no_error to figure out how we want to do the key value thing mapping thing
        PassengerData passenger = new PassengerData(CSV.PASSENGER_DATA.getClasspath());
        AirportData airport = new AirportData(CSV.TOP_30.getClasspath());
        LinkedList<PassengerMapper> mappers = new LinkedList<>();
        LinkedList<AirportMapper> airportMappers = new LinkedList<>();
        HashMap<String, Flight> newHashMap;
        HashMap<String, Airport> airportHashMap;
        Reducer reducer = null;

        // Split data into chunks of the specified size
        List<List<String[]>> passengerData = ListUtils.partition(passenger.getLines(), 20);
        List<List<String[]>> airportData = ListUtils.partition(airport.getLines(), 5);
        // Create n number of mappers depending on number of partitions made.
        for(List<String[]> l : passengerData){
            mappers.add(new PassengerMapper(l));
            mappers.getLast().run();
        }
        // Do the same for airport data
        for(List<String[]> l : airportData){
            airportMappers.add(new AirportMapper(l));
            airportMappers.getLast().run();
        }

        try {
            // Wait for all threads to finish before continuing.
            for(PassengerMapper m : mappers)
                m.join();
            for(AirportMapper m : airportMappers)
                m.join();
        }
        catch (InterruptedException e) {
            log.error(e.getLocalizedMessage());
            // Kill code execution if something went wrong with any of the threads.
            return;
        }

        /* Technically the shuffle part is what is being attempting now
         * Just need to merge the Passenger lists somehow. */
        newHashMap = new HashMap<>();
        airportHashMap = new HashMap<>();

        /* Merge all of the HashMaps into a single HashMap by iterating
         * through each of the mappers and merging the contents to newHashMap */
        for(PassengerMapper m : mappers) {
            //System.out.println(m.getHashMap().toString());
            /*So each mapper has a HashMap<String, Flight>
             *We want to merge them so the reduce step is trivial.
             *
             * Iterate with .forEach and merge to the newHashMap
             * In the merge, v1 and v2 represent a Hash value in
             * the newHashMap and HashMap from the current mapper
             * respectively */
            m.getHashMap().entrySet()
                    .forEach(entry -> newHashMap.merge(
                            entry.getKey(),
                            entry.getValue(),
                            (v1, v2) -> v1.mergePassengers(v2.getPassengers())
                    ));
        }

        /*
         * For airport data, need to a similar thing really
         * though no data needs to be merged as there shouldn't be
         * any duplicate. Data reading and mapping state serve as two
         * blockades for any duplicate data. Makes this step pretty
         * straightforward.
         */
        for(AirportMapper m : airportMappers) {
            airportHashMap.putAll(m.getHashMap());
        }

        // Now to need to do the reduce step now to finish the assignment!

        reducer = new Reducer(newHashMap, airportHashMap);

        System.out.println(reducer.getSrcAirportsUsed());                   // Determine the number of flights **from** each airport; include a list of any airports not used.
        System.out.println(reducer.getListOfFlights());                     // Create a list of flights based on the Flight id.
        System.out.println(reducer.getNumOfPassengersForEachFlight());      // Calculate the number of passengers on each flight.
        System.out.println(reducer.getDistances());                         // Calculate number of nautical miles done by each passenger
    }
}
