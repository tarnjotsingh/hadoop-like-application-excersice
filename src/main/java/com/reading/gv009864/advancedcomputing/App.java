/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.reading.gv009864.advancedcomputing;

import com.reading.gv009864.advancedcomputing.airline.Flight;
import com.reading.gv009864.advancedcomputing.data.AirportData;
import com.reading.gv009864.advancedcomputing.data.PassengerData;
import com.reading.gv009864.advancedcomputing.strings.CSV;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.commons.collections4.ListUtils;


import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

public class App {
    private static Logger log = LoggerFactory.getLogger(App.class);

    /*
        Create a list of flights based on the Flight ID
        Output should include passenger ID
        <key, List<value>>
        <FlightId, List<data>>
     */


    public static void main(String[] args) {
        // I guess the first thing to do would be to take the data in and read it before carrying on
        // Need to Map the input data to key value pairs
        // Will just work on doing the mapping the input to key value pairs for the first part before carrying on to the other steps in the process.

        // Lets take the AComp_passenger_data_no_error to figure out how we want to do the key value thing mapping thing
        PassengerData passenger = new PassengerData(CSV.PASSENGER_DATA.getClasspath());
        System.out.println(passenger.getLines());

        AirportData airport = new AirportData(CSV.TOP_30.getClasspath());
        System.out.println(airport.getLines());

        LinkedList<Mapper> mappers = new LinkedList<>();

        // Split data into chunks of 20.
        List<List<String[]>> data2 = ListUtils.partition(passenger.getLines(), 5);

        // Add a new mapper and run it
        for(List<String[]> l : data2){
            mappers.add(new Mapper(l));
            mappers.getLast().run();
        }

        try {
            // I guess try to join all the Threaded mappers.
            for(Mapper m : mappers)
                m.join();
        }
        catch (InterruptedException e)
        {
            log.error(e.getLocalizedMessage());
        }

        /* Technically the shuffle part is what I am attempting now
         * Just need to map the Passenger lists somehow. */

        HashMap<String, Flight> newHashMap = new HashMap<>();

        // Merge all of the HashMaps into a single HashMap.
        for(Mapper m : mappers) {
            System.out.println(m.getHashMap().toString());
            /*So each mapper has a HashMap<String, Flight>
             *We want to merge them so the reduce step is trivial#
             *
             * Iterate with .forEach and merge to the newHashMap*/
            m.getHashMap().entrySet()
                    .forEach(entry -> newHashMap.merge(
                            entry.getKey(),
                            entry.getValue(),
                            (v1, v2) -> v1.mergePassengers(v2.getPassengers())
                    ));
        }


        System.out.println("\n" + newHashMap.toString());
    }
}
